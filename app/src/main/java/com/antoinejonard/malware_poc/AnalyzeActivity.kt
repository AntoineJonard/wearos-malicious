package com.antoinejonard.malware_poc

import android.Manifest
import android.app.Activity
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Bundle
import android.os.Environment
import android.os.Environment.getExternalStoragePublicDirectory
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import com.antoinejonard.malware_poc.databinding.ActivityAnalyzeBinding
import kotlinx.coroutines.*
import java.io.*
import java.math.BigInteger
import java.nio.file.Files
import java.security.MessageDigest


private const val nbMalwareHashs = 69072

class AnalyzeActivity : AppCompatActivity(), CoroutineScope by MainScope() {

    private lateinit var binding: ActivityAnalyzeBinding

    private lateinit var progressBar: ProgressBar
    private lateinit var progressPercentLabel : TextView
    private var nbMalware = 0
    var nbMalwareCheck = 0

    private val permissions = arrayOf(
        Manifest.permission.ACCESS_FINE_LOCATION,
        Manifest.permission.ACCESS_COARSE_LOCATION,
        Manifest.permission.READ_EXTERNAL_STORAGE
    )

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        binding = ActivityAnalyzeBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // If user finishes the activity before analysis ended
        setResult(Activity.RESULT_CANCELED, Intent())

        progressBar = binding.progressBar
        progressPercentLabel = binding.progressPercentLabel

        hasPermissions(applicationContext, *permissions)
        binding.progressDetails.text = getString(R.string.no_reading_permission)
    }

    private fun analyzeDownloads() {

        val downloadFolder = getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)

        if (downloadFolder != null) {

            nbMalwareCheck = nbMalwareHashs * (downloadFolder.listFiles()?.size ?: 0)
            progressBar.max = nbMalwareCheck
            progressBar.min = 0
            progressBar.progress = 0

            launch(Dispatchers.IO) {

                for (f in downloadFolder.listFiles()!!) {
                    analyzeFile(f)
                }

                withContext(Dispatchers.Main){
                    binding.progressDetails.text = nbMalware.toString().plus(" malware(s) detected")
                }

                if (nbMalware <= 0){
                    setResult(Activity.RESULT_OK, Intent().apply {
                        putExtra("malware",false)
                    })
                }else {
                    setResult(Activity.RESULT_OK, Intent().apply {
                        putExtra("malware",true)
                    })
                }
            }
        }
    }

    private suspend fun analyzeFile(f: File) {
        var readLine: String? = null

        val fileBytes: ByteArray = Files.readAllBytes(f.toPath())
        val md5hash = md5(fileBytes)

        val inputStream: InputStream = this.resources.openRawResource(R.raw.md5_virus_hash)
        val br = BufferedReader(InputStreamReader(inputStream))

        withContext(Dispatchers.Main){
            binding.progressDetails.text = "Analyzing ".plus(f.name).plus("...")
        }

        try {
            // While the BufferedReader readLine is not null
            while (br.readLine().also { readLine = it } != null) {
                if (readLine.equals(md5hash))
                    nbMalware++
                updateProgress()
            }

            br.close()
            inputStream.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    private suspend fun updateProgress() {
        withContext(Dispatchers.Main){
            progressBar.progress++
            progressPercentLabel.text = String.format(getString(R.string.progres_percent), (progressBar.progress / nbMalwareCheck.toDouble() * 100).toInt())
        }
    }

    private fun md5(input: ByteArray): String {
        val md = MessageDigest.getInstance("MD5")
        return BigInteger(1, md.digest(input)).toString(16).padStart(32, '0')
    }

    private fun hasPermissions(context: Context, vararg permissions: String) {

        val permissionsToAsk : ArrayList<String> = arrayListOf()

        for (permission in permissions) {
            if (ActivityCompat.checkSelfPermission(
                    context,
                    permission
                ) != PackageManager.PERMISSION_GRANTED
            ) {
                permissionsToAsk.add(permission)
            }
        }

        if (permissionsToAsk.isNotEmpty())
            ActivityCompat.requestPermissions(this, permissionsToAsk.toTypedArray(),1)
        else
            analyzeDownloads()
    }

    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)

        when (requestCode) {
            1 -> {
                var allGranted = true
                permissions.forEachIndexed { index, _ -> if (grantResults[index] != 0) allGranted = false }
                if (allGranted){
                    analyzeDownloads()
                }
                return
            }
        }
    }
}
