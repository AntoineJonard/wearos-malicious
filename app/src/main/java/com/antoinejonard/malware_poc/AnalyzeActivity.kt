package com.antoinejonard.malware_poc

import android.Manifest
import android.app.Activity
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Bundle
import android.os.Environment
import android.os.Environment.getExternalStoragePublicDirectory
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import com.antoinejonard.malware_poc.databinding.ActivityAnalyzeBinding
import kotlinx.coroutines.*
import java.io.*
import java.math.BigInteger
import java.nio.file.Files
import java.security.MessageDigest


private const val nbMalwareHashs = 69072

class AnalyzeActivity : AppCompatActivity(), CoroutineScope by MainScope() {

    private lateinit var binding: ActivityAnalyzeBinding

    private lateinit var progressBar: ProgressBar
    private lateinit var progressPercentLabel : TextView
    private var nbMalware = 0
    var nbMalwareCheck = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        binding = ActivityAnalyzeBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // If user finishes the activity before analysis ended
        setResult(Activity.RESULT_CANCELED, Intent())

        progressBar = binding.progressBar
        progressPercentLabel = binding.progressPercentLabel

        if (hasPermissions(applicationContext,Manifest.permission.READ_EXTERNAL_STORAGE))
            analyzeDownloads()
        else
            binding.progressDetails.text = getString(R.string.no_reading_permission)
    }

    private fun analyzeDownloads() {

        val downloadFolder = getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)

        if (downloadFolder != null) {


            nbMalwareCheck = nbMalwareHashs * (downloadFolder.listFiles()?.size ?: 0)
            progressBar.max = nbMalwareCheck
            progressBar.min = 0
            progressBar.progress = 0

            launch(Dispatchers.IO) {

                for (f in downloadFolder.listFiles()!!) {
                    analyzeFile(f)
                }

                withContext(Dispatchers.Main){
                    binding.progressDetails.text = nbMalware.toString().plus(" malware(s) detected")
                }

                if (nbMalware <= 0){
                    setResult(Activity.RESULT_OK, Intent().apply {
                        putExtra("malware",false)
                    })
                }else {
                    setResult(Activity.RESULT_OK, Intent().apply {
                        putExtra("malware",true)
                    })
                }
            }
        }
    }

    private suspend fun analyzeFile(f: File) {
        var readLine: String? = null

        val fileBytes: ByteArray = Files.readAllBytes(f.toPath())
        val md5hash = md5(fileBytes)

        val inputStream: InputStream = this.resources.openRawResource(R.raw.md5_virus_hash)
        val br = BufferedReader(InputStreamReader(inputStream))

        withContext(Dispatchers.Main){
            binding.progressDetails.text = "Analyzing ".plus(f.name).plus("...")
        }

        try {
            // While the BufferedReader readLine is not null
            while (br.readLine().also { readLine = it } != null) {
                if (readLine.equals(md5hash))
                    nbMalware++
                updateProgress()
            }

            br.close()
            inputStream.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    private suspend fun updateProgress() {
        withContext(Dispatchers.Main){
            progressBar.progress++
            progressPercentLabel.text = String.format(getString(R.string.progres_percent), (progressBar.progress / nbMalwareCheck.toDouble() * 100).toInt())
        }
    }

    private fun md5(input: ByteArray): String {
        val md = MessageDigest.getInstance("MD5")
        return BigInteger(1, md.digest(input)).toString(16).padStart(32, '0')
    }

    private fun hasPermissions(context: Context, vararg permissions: String): Boolean {
        for (permission in permissions) {
            if (ActivityCompat.checkSelfPermission(
                    context,
                    permission
                ) != PackageManager.PERMISSION_GRANTED
            ) {
                ActivityCompat.requestPermissions(this, arrayOf(permission),1)
                return false
            }
        }
        return true
    }

    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)

        when (requestCode) {
            1 -> {
                // If request is cancelled, the result arrays are empty.
                if (grantResults.isNotEmpty()
                    && grantResults[0] == PackageManager.PERMISSION_GRANTED
                ) {

                    // permission was granted, yay! Do the
                    // contacts-related task you need to do.
                    Toast.makeText(applicationContext, "permission was granted", Toast.LENGTH_SHORT)
                        .show()
                    analyzeDownloads()
                } else {

                    // permission denied, boo! Disable the
                    // functionality that depends on this permission.
                    Toast.makeText(applicationContext, "Permission denied", Toast.LENGTH_SHORT)
                        .show()
                }
                return
            }
        }
    }
}
